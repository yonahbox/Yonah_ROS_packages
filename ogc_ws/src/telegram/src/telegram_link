#!/usr/bin/env python3

# Copyright (C) 2020 Rumesh Sudhaharan

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import rospy
from std_msgs.msg import String
from despatcher.msg import LinkMessage
from identifiers.srv import GetDetails, AddTelegramId, CheckSender
from telegram.msg import ContactInfo

import sys
import os
from threading import Thread
import json

from Td import Td

# callback function for listening to the ogc/to_telegram topic
def tdlib_topic_cb(msg, args):
	td = args[0]
	id_service = args[1]
	tele_id = id_service(msg.id)
	if tele_id.data_int == 0:
		rospy.logwarn("Invalid user id")
	else:
		rospy.loginfo("sending message to " + str(tele_id.data_int))
		td.send_message(tele_id.data_int, msg.data)

# callback function run to add a contact to the telegram account
def tdlib_add_contact_cb(contact, td):
	rospy.loginfo("Received request to add contact " + contact.label + " " + contact.number)
	td.add_contact(contact.number, contact.label)
	# td.get_contacts()

# Function to receive all messages from telegram
# runs in a seperate thread
def tdlib_recv():
	from_tele_pub = rospy.Publisher('ogc/from_telegram', String, queue_size=10)
	identifiers_add_tele_id = rospy.ServiceProxy("identifiers/add/telegram_id", AddTelegramId)
	is_valid_sender_service = rospy.ServiceProxy("identifiers/check/proper", CheckSender)
	# Loop runs indefinitely, checking for any updates in telegram
	boot_time = rospy.get_rostime().secs
	while True: 
		event = td.receive()
		if event:
			rospy.logdebug(event)
			# log details if there is an error
			if event['@type'] == 'error':
				rospy.logwarn(json.dumps(event))

			if event['@type'] == 'user':
				print(event)
				result = identifiers_add_tele_id(event["phone_number"], event["id"])

			# new message received 
			if event['@type'] == 'updateNewMessage':
				# ignore outgoing messages and messages sent before the node was started
				if event['message']['is_outgoing'] or event["message"]["date"] < boot_time:
					continue

				# Check if sender is from a whitelisted contact
				is_valid_sender = is_valid_sender_service(0, str(event["message"]["sender_user_id"]))
				if not is_valid_sender.result:
					continue

				message = event['message']['content']['text']['text']
				from_tele_pub.publish(message)

				# Mark message as read
				td.set_read(event["message"]["chat_id"], event["message"]["id"])

				rospy.loginfo("Incoming message from command user: %s", message)

if __name__ == '__main__':
	try:
		rospy.init_node('tele_ros', anonymous=False, disable_signals=True)
		tdlib_dir = rospy.get_param("~tdlib_auth_dir")			# Location of the telegram account, created by the tele_auth script
		valid_ids = rospy.get_param("~valid_ids") 				# whitelisted ids, if this is running in the air, valid_ids will only have ground ids and vice versa

		# wait for required services to be available before continuing
		rospy.wait_for_service("identifiers/get/telegram_id")
		rospy.wait_for_service("identifiers/add/telegram_id")
		rospy.wait_for_service("identifiers/check/proper")

		# Service to get the telegram user id from identifiers
		identifiers_get_telegram_id = rospy.ServiceProxy("identifiers/get/telegram_id", GetDetails)

		# Initialize Td class, handles all the telegram actions for the node
		td = Td(tdlib_dir)

		# Creates a new thread for running the receive function
		recv_thread = Thread(target=tdlib_recv)
		recv_thread.daemon = True
		recv_thread.start()

		rospy.Subscriber('ogc/to_telegram', LinkMessage, tdlib_topic_cb, (td, identifiers_get_telegram_id))
		rospy.Subscriber('ogc/to_telegram/contact', ContactInfo, tdlib_add_contact_cb, td)

		# inform all valid nodes that the link is up
		# td.send_message_multi(valid_ids, ("Air" if is_air else "Ground") + " id " + str(self_id) + " Setup complete")

		rospy.spin()

	except rospy.ROSInterruptException:
		sys.stdout.flush()
		td.destroy()
		exit()
	except KeyboardInterrupt:
		sys.stdout.flush()
		td.destroy()
		exit()
	
