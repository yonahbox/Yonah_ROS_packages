#!/usr/bin/env python3

# Copyright (C) 2020 Rumesh Sudhaharan

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import rospy
from std_msgs.msg import String
from despatcher.msg import LinkMessage
from identifiers.srv import GetDetails

import sys
import os
from threading import Thread
import json

from Td import Td, Chat

# callback function for listening to the ogc/to_telegram topic
def tdlib_topic_cb(msg, td):
	td.send_message(msg.id, msg.data)

# Function to receive all messages from telegram
# runs in a seperate thread
def tdlib_recv():
	from_tele_pub = rospy.Publisher('ogc/from_telegram', String, queue_size=10)
	# Loop runs indefinitely, checking for any updates in telegram
	boot_time = rospy.get_rostime().secs
	while True: 
		event = td.receive()
		if event:
			rospy.logdebug(event)
			# log details if there is an error
			if event['@type'] == 'error':
				rospy.logwarn(json.dumps(event))
			# new message received 
			if event['@type'] == 'updateNewMessage':
				# ignore outgoing messages and messages sent before the node was started
				if event['message']['is_outgoing'] or event["message"]["date"] < boot_time:
					continue

				# ignore messages sent before node was started
				# if event['message']['date'] < boot_time:
					# rospy.loginfo("Ignoring old messages")
					# continue

				#checks if the message received is from a whitelisted number
				# td already has a "whitelist" when it is setup
				sender_number = td.get_chat_number(event["message"]["sender_user_id"])
				if not sender_number:
					continue

				message = event['message']['content']['text']['text']
				from_tele_pub.publish(message)

				# Mark message as read
				td.set_read(event["message"]["chat_id"], event["message"]["id"])

				rospy.loginfo("Incoming message from command user: %s", message)
				
				# For testing purposes
				# if message.lower() == 'pic':
				# 	td.send_image('/home/ubuntu/test_pic.jpg')
				# if message.lower() == 'loc':
				# 	td.send_location('kompiam', (-5.38333333,143.92250000))
				# if message.lower() == 'vid':
				# 	td.send_video('/home/ubuntu/test_vid.mp4')

if __name__ == '__main__':
	try:
		rospy.init_node('tele_ros', anonymous=False, disable_signals=True)
		tdlib_dir = rospy.get_param("~tdlib_auth_dir")			# Location of the telegram account, created by the tele_auth script
		valid_ids = rospy.get_param("~valid_ids") 				# whitelisted ids, if this is running in the air, valid_ids will only have ground ids and vice versa

		rospy.wait_for_service("identifiers/get/number")

		identifiers_get_number = rospy.ServiceProxy("identifiers/get/number", GetDetails)

		whitelist_info = {}
		for id_n in valid_ids:
			number = identifiers_get_number(id_n)
			if number.data:
				whitelist_info[id_n] = number.data


		# Initialize Td class, handles all the telegram actions for the node
		td = Td(tdlib_dir, whitelist_info)

		# Creates a new thread for running the receive function
		recv_thread = Thread(target=tdlib_recv)
		recv_thread.daemon = True
		recv_thread.start()

		rospy.Subscriber('ogc/to_telegram', LinkMessage, tdlib_topic_cb, td)

		# Checks if the Td class has finished initializing
		# This involves ensuring that it is able to send messages to all devices in valid_ids
		rate = rospy.Rate(1)
		while not td.setup_complete():
			rospy.loginfo("NOT COMPLETE YET")
			td.get_contacts()
			# td.receive()
			rate.sleep()

		rospy.loginfo('setup complete')

		# inform all valid nodes that the link is up
		# td.send_message_multi(valid_ids, ("Air" if is_air else "Ground") + " id " + str(self_id) + " Setup complete")

		rospy.spin()

	except rospy.ROSInterruptException:
		sys.stdout.flush()
		td.destroy()
		exit()
	except KeyboardInterrupt:
		sys.stdout.flush()
		td.destroy()
		exit()
	
