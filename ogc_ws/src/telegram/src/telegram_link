#!/usr/bin/env python3

# Copyright (C) 2020 Rumesh Sudhaharan

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import rospy
from std_msgs.msg import String
from despatcher.msg import LinkMessage
from identifiers.srv import GetDetails, AddTelegramId, CheckSender
from telegram.msg import ContactInfo

import sys
import os
from pathlib import Path
from threading import Thread
import json

from Td import Td

# callback function for listening to the ogc/to_telegram topic
def tdlib_topic_cb(msg, args):
	td = args[0]					# instance of Td class
	id_service = args[1]			# service proxy for identifers service to get the telegram user id
	tele_id = id_service(msg.id)	# get the telegram user id to send the message to

	if tele_id.data_int == 0:
		rospy.logwarn("Invalid user id")
	else:
		rospy.loginfo("sending message to " + str(tele_id.data_int))
		td.send_message(tele_id.data_int, msg.data)

# callback function run to add a contact to the telegram account
def tdlib_add_contact_cb(contact, td):
	rospy.loginfo("Received request to add contact " + contact.label + " " + contact.number)

	# check if the requested contact is the account itself
	if contact.me:
		td.get_me()										# get information about this telegram account
	else:
		td.add_contact(contact.number, contact.label)	# add new contacts to the telegram account
	td.get_contacts()									# refresh contacts to get the user ids

def tdlib_file_cb(msg, args):
	td = args[0]
	id_service = args[1]
	tele_id = id_service(msg.id)

	if tele_id.data_int == 0:
		rospy.logwarn("Invalid user id")
		return

	rospy.loginfo("SENDING FILE")
	home_dir = str(Path.home())
	file_path = home_dir + "/Waypoints/" + msg.data
	td.send_file(tele_id.data_int, file_path)

# Function to receive all messages from telegram
# runs in a seperate thread
def tdlib_recv():
	from_tele_pub = rospy.Publisher('ogc/from_telegram', String, queue_size=10)
	identifiers_add_tele_id = rospy.ServiceProxy("identifiers/add/telegram_id", AddTelegramId)
	is_valid_sender_service = rospy.ServiceProxy("identifiers/check/proper", CheckSender)
	# Loop runs indefinitely, checking for any updates in telegram
	boot_time = rospy.get_rostime().secs

	while True: 
		event = td.receive()
		if event:
			rospy.logdebug(event)
			# log details if there is an error
			if event['@type'] == 'error':
				rospy.logwarn(json.dumps(event))

				# get chats to fix chat not found error
				td.get_chats()

			# For knowing status of downloading files
			if event['@type'] == 'updateFile':
				# Check if the file has finished downloading
				if event['file']['local']['is_downloading_completed']:
					local_path = event['file']['local']['path']

					# Currenly only supports sending waypoint files
					home_dir = str(Path.home())
					final_path = home_dir + "/Waypoints/" + os.path.basename(local_path)
					
					# Move the file
					os.rename(local_path, final_path)
					#from_tele_pub.publish(f"File {final_path} Downloaded")

			# information about a user ( used to get the user id)
			if event['@type'] == 'user':
				# print(event)
				result = identifiers_add_tele_id(event["phone_number"], event["id"])

			# new message received 
			if event['@type'] == 'updateNewMessage':
				# ignore outgoing messages and messages sent before the node was started
				if event['message']['is_outgoing'] or event["message"]["date"] < boot_time:
					continue

				# Check if sender is from a whitelisted contact
				is_valid_sender = is_valid_sender_service(0, str(event["message"]["sender_user_id"]))
				if not is_valid_sender.result:
					continue

				# rospy.loginfo(json.dumps(event))

				message_type = event['message']['content']['@type']
				if message_type == 'messageText':
					message = event['message']['content']['text']['text']
					# rospy.logwarn(message)
					from_tele_pub.publish(message)

					# Mark message as read
					td.set_read(event["message"]["chat_id"], event["message"]["id"])
					rospy.loginfo("Incoming message from %d: %s", event["message"]["sender_user_id"], message)

				elif message_type == 'messageDocument':
					file_id = event['message']['content']['document']['document']['id']
					local_path = event['message']['content']['document']['document']['local']['path']

					# download the file
					if local_path != 1:
						td.download_file(file_id)

if __name__ == '__main__':
	try:
		rospy.init_node('tele_ros', anonymous=False, disable_signals=True)
		tdlib_dir = rospy.get_param("~tdlib_auth_dir")			# Location of the telegram account, created by the tele_auth script
		valid_ids = rospy.get_param("~valid_ids") 				# whitelisted ids, if this is running in the air, valid_ids will only have ground ids and vice versa

		# wait for required services to be available before continuing
		rospy.wait_for_service("identifiers/get/telegram_id")
		rospy.wait_for_service("identifiers/add/telegram_id")
		rospy.wait_for_service("identifiers/check/proper")

		# Service to get the telegram user id from identifiers
		identifiers_get_telegram_id = rospy.ServiceProxy("identifiers/get/telegram_id", GetDetails)

		# Initialize Td class, handles all the telegram actions for the node
		td = Td(tdlib_dir)

		documents_dir = tdlib_dir + "/documents"
		for file in Path(documents_dir).iterdir():
			file.unlink()


		# Creates a new thread for running the receive function
		recv_thread = Thread(target=tdlib_recv)
		recv_thread.daemon = True
		recv_thread.start()

		rospy.Subscriber('ogc/to_telegram', LinkMessage, tdlib_topic_cb, (td, identifiers_get_telegram_id))
		rospy.Subscriber('ogc/to_telegram/file', LinkMessage, tdlib_file_cb, (td, identifiers_get_telegram_id))
		rospy.Subscriber('ogc/to_telegram/contact', ContactInfo, tdlib_add_contact_cb, td)

		# inform all valid nodes that the link is up
		# td.send_message_multi(valid_ids, ("Air" if is_air else "Ground") + " id " + str(self_id) + " Setup complete")

		rospy.spin()

	except rospy.ROSInterruptException:
		sys.stdout.flush()
		td.destroy()
		exit()
	except KeyboardInterrupt:
		sys.stdout.flush()
		td.destroy()
		exit()
	
