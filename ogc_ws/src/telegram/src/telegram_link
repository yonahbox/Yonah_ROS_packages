#!/usr/bin/env python3

# Copyright (C) 2020 Rumesh Sudhaharan

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import rospy
from std_msgs.msg import String
from despatcher.msg import LinkMessage

import sys
import os
from threading import Thread
import json

from Td import Td, Chat

# callback function for listening to the ogc/to_telegram topic
def tdlib_topic_cb(msg, td):
	td.send_message(msg.id, msg.data)

# Function to receive all messages from telegram
# runs in a seperate thread
def tdlib_recv():
	from_tele_pub = rospy.Publisher('ogc/from_telegram', String, queue_size=10) 
	# Loop runs indefinitely, checking for any updates in telegram
	while True: 
		event = td.receive()
		if event:
			rospy.logdebug(event)
			# log details if there is an error
			if event['@type'] == 'error':
				rospy.logwarn(json.dumps(event))
			#checks if the message received is from a whitelisted number
			if event['@type'] == 'updateNewMessage' and event['message']['sender_user_id'] in td.command_user_ids:
				# ignore outgoing messages
				if event['message']['is_outgoing'] == True:
					return

				message = event['message']['content']['text']['text']
				from_tele_pub.publish(message)
				rospy.loginfo("Incoming message from command user: %s", message)
				
				# For testing purposes
				# if message.lower() == 'pic':
				# 	td.send_image('/home/ubuntu/test_pic.jpg')
				# if message.lower() == 'loc':
				# 	td.send_location('kompiam', (-5.38333333,143.92250000))
				# if message.lower() == 'vid':
				# 	td.send_video('/home/ubuntu/test_vid.mp4')

if __name__ == '__main__':
	try:
		rospy.init_node('tele_ros', anonymous=False)
		tdlib_dir = rospy.get_param("~tdlib_auth_dir")			# Location of the telegram account, created by the tele_auth script
		identifiers_file = rospy.get_param("~identifiers_file")	# Location of the identifiers file
		valid_ids = rospy.get_param("~valid_ids") 				# whitelisted ids, if this is running in the air, valid_ids will only have ground ids and vice versa
		is_air = rospy.get_param("~is_air")						# Boolean value to check if this is running in the air side or ground side
		self_id = rospy.get_param("~self_id") 					# id of the device this is running on

		# Initialize Td class, handles all the telegram actions for the node
		td = Td(tdlib_dir, identifiers_file, is_air, valid_ids)

		# Creates a new thread for running the receive function
		recv_thread = Thread(target=tdlib_recv)
		recv_thread.daemon = True
		recv_thread.start()

		rospy.Subscriber('ogc/to_telegram', LinkMessage, tdlib_topic_cb, td)

		# Checks if the Td class has finished initializing
		# This involves ensuring that it is able to send messages to all devices in valid_ids
		rate = rospy.Rate(1)
		while not td.setup_complete():
			rospy.loginfo("NOT COMPLETE YET")
			td.get_chats()
			rate.sleep()

		rospy.loginfo('setup complete')

		# inform all valid nodes that the link is up
		td.send_message_multi(valid_ids, ("Air" if is_air else "Ground") + " id " + str(self_id) + " Setup complete")

		rospy.spin()

	except rospy.ROSInterruptException:
		sys.stdout.flush()
		td.destroy()
		exit()
	except KeyboardInterrupt:
		sys.stdout.flush()
		td.destroy()
		exit()
	
