#!/usr/bin/env python3

# Copyright (C) 2020 Rumesh Sudhaharan

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import rospy
from std_msgs.msg import String
from despatcher.msg import LinkMessage
from identifiers.srv import GetDetails, AddTelegramId, CheckSender
from telegram.msg import ContactInfo

import timeoutscript

import os
from pathlib import Path
from threading import Thread
import json

from Td import Td

msg_success = {}

class TimeoutClass():
	def __init__(self, uuid):
		self.uuid = uuid
		self.time = 5
		self.pub_to_switcher = rospy.Publisher('ogc/to_switcher_tele', String, queue_size=5)

	def countdown(self, data):
		self.time -= 1
		if self.time <= 0:
			self.timer.shutdown()
			self.pub_to_switcher.publish("Timeout")
	
	def persec(self):
		self.timer = rospy.Timer(rospy.Duration(1), self.countdown)

# callback function for listening to the ogc/to_telegram topic
def tdlib_topic_cb(msg, args):
	td = args[0]					# instance of Td class
	id_service = args[1]			# service proxy for identifers service to get the telegram user id
	tele_id = id_service(msg.id)	# get the telegram user id to send the message to
	if tele_id.data_int == 0:
		rospy.logwarn("Invalid user id")
		return

	td.create_chat(tele_id.data_int)

	ack = timeoutscript.ack_converter(msg, 1)
	if ack != None:
		pub_to_timeout.publish(ack)
	# args[2] contains the type of message to send
	#	0: text
	#	1: file
	if args[2] == 0:
		if msg.uuid > 0:
			msg_success[msg.uuid] = TimeoutClass(msg.uuid)
			msg_success[msg.uuid].persec()
		rospy.logerr("sending message to " + str(tele_id.data_int))
		td.send_message(tele_id.data_int, msg.data)
	elif args[2] == 1:
		rospy.logerr("SENDING FILE")
		home_dir = str(Path.home())
		file_path = home_dir + "/Sync/" + msg.data
		td.send_file(tele_id.data_int, file_path, msg.data)
	else:
		rospy.logerr(args)

# callback function run to add a contact to the telegram account
def tdlib_add_contact_cb(contact, td):
	rospy.loginfo("Received request to add contact " + contact.label + " " + contact.number)

	# check if the requested contact is the account itself
	if contact.me:
		td.get_me()										# get information about this telegram account
	else:
		td.add_contact(contact.number, contact.label)	# add new contacts to the telegram account
	td.get_contacts()									# refresh contacts to get the user ids

def tdlib_admin_cb(msg, td):
	get_admin_id = rospy.ServiceProxy("identifiers/get/admin_id", GetDetails)
	admin_id = get_admin_id()
	td.send_message(admin_id.data_int, msg.data)

# Function to receive all messages from telegram
# runs in a seperate thread
def tdlib_recv():
	from_tele_pub = rospy.Publisher('ogc/from_telegram', String, queue_size=10)
	identifiers_add_tele_id = rospy.ServiceProxy("identifiers/add/telegram_id", AddTelegramId)
	is_valid_sender_service = rospy.ServiceProxy("identifiers/check/proper", CheckSender)
	boot_time = rospy.get_rostime().secs

	file_locations = {}

	# Loop runs indefinitely, checking for any updates in telegram
	while True: 
		event = td.receive()
		if event:
			# print(event)
			rospy.logdebug(event)
			# log details if there is an error
			if event['@type'] == 'error':
				rospy.logwarn(json.dumps(event))

				# get chats to fix chat not found error
				td.get_chats()

			# For knowing status of downloading files
			if event['@type'] == 'updateFile':
				# Check if the file has finished downloading
				if event['file']['local']['is_downloading_completed']:
					local_path = event['file']['local']['path']
					file_id = event['file']['id']

					# Currenly only supports sending waypoint files
					base_dir = str(Path.home()) + "/Sync/"
					try:
						sender, final_dir = file_locations[file_id]
					except KeyError:
						continue

					final_path = base_dir + final_dir
					final_dir_path = Path(os.path.dirname(final_path))
					final_dir_path.mkdir(parents=True, exist_ok=True)
					
					# Move the file
					os.rename(local_path, final_path)
					# Acknowledgement
					td.send_message(sender, final_dir)

			# information about a user ( used to get the user id)
			if event['@type'] == 'user':
				result = identifiers_add_tele_id(event["phone_number"], event["id"])

			# new message received 
			if event['@type'] == 'updateNewMessage':
				# ignore outgoing messages and messages sent before the node was started
				if event['message']['is_outgoing'] or event["message"]["date"] < boot_time:
					continue

				# Check if sender is from a whitelisted contact
				is_valid_sender = is_valid_sender_service(0, str(event["message"]["sender_user_id"]))
				sender = event["message"]["sender_user_id"]
				if not is_valid_sender.result:
					continue

				message_type = event['message']['content']['@type']
				if message_type == 'messageText':
					message = event['message']['content']['text']['text']
					# rospy.logwarn(message)
					from_tele_pub.publish(message)

					# Mark message as read
					td.set_read(event["message"]["chat_id"], event["message"]["id"])
					rospy.loginfo("Incoming message from %d: %s", event["message"]["sender_user_id"], message)

				elif message_type == 'messageDocument':
					file_id = event['message']['content']['document']['document']['id']
					local_path = event['message']['content']['document']['document']['local']['path']
					final_path = event['message']['content']['caption']['text']

					# download the file
					if local_path != 1:
						td.download_file(file_id)
						file_locations[file_id] = final_path

			# if event['@type'] == 'updateMessageSendSucceeded':
			# 	success_uuid = int(event["message"]["content"]["text"]["text"].split()[3])
			# 	if success_uuid > 0:
			# 		msg_success[success_uuid].timer.shutdown()
			# 		msg_success[success_uuid].pub_to_switcher.publish("Success")


if __name__ == '__main__':
	try:
		rospy.init_node('tele_ros', anonymous=False, disable_signals=True)
		tdlib_dir = rospy.get_param("~tdlib_auth_dir")			# Location of the telegram account, created by the tele_auth script

		# wait for required services to be available before continuing
		rospy.wait_for_service("identifiers/get/telegram_id")
		rospy.wait_for_service("identifiers/add/telegram_id")
		rospy.wait_for_service("identifiers/check/proper")
		rospy.wait_for_service("identifiers/get/admin_id")

		# Service to get the telegram user id from identifiers
		identifiers_get_telegram_id = rospy.ServiceProxy("identifiers/get/telegram_id", GetDetails)

		# Initialize Td class, handles all the telegram actions for the node
		td = Td(tdlib_dir)

		documents_dir = tdlib_dir + "/documents"
		for file in Path(documents_dir).iterdir():
			file.unlink()


		# Creates a new thread for running the receive function
		recv_thread = Thread(target=tdlib_recv)
		recv_thread.daemon = True
		recv_thread.start()

		rospy.Subscriber('ogc/to_telegram', LinkMessage, tdlib_topic_cb, (td, identifiers_get_telegram_id, 0))
		rospy.Subscriber('ogc/to_telegram/file', LinkMessage, tdlib_topic_cb, (td, identifiers_get_telegram_id, 1))
		rospy.Subscriber('ogc/to_telegram/contact', ContactInfo, tdlib_add_contact_cb, td)
		pub_to_timeout = rospy.Publisher('ogc/to_timeout', LinkMessage, queue_size = 5)
		rospy.Subscriber('ogc/to_telegram/admin', String, tdlib_admin_cb, td)
		# inform all valid nodes that the link is up
		# td.send_message_multi(valid_ids, ("Air" if is_air else "Ground") + " id " + str(self_id) + " Setup complete")

		rospy.spin()

	except rospy.ROSInterruptException:
		sys.stdout.flush()
		td.destroy()
		exit()
	except KeyboardInterrupt:
		sys.stdout.flush()
		td.destroy()
		exit()
	
